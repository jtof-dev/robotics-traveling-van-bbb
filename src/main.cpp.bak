#include "hardware/gpio.h"
#include "hardware/i2c.h"
#include "hardware/timer.h"
#include "pico/multicore.h"
#include "pico/stdlib.h"
#include <stdio.h>

#include "VL53L0X.h"
#include "configuration.hpp"
#include "pid.h"

#define I2C_PORT i2c0
#define SDA_PIN 4
#define SCL_PIN 5

// future touchscreen commands
#define CMD_UPDATE_KP 0x01
#define CMD_UPDATE_KI 0x02
#define CMD_UPDATE_KD 0x03

volatile int motor_pwm_delay = 1000;
volatile bool motor_enabled = false;
volatile int motor_direction = CLOCKWISE;

bool motor_step_callback(struct repeating_timer *t) {
  static bool step_state = false;
  if (motor_enabled) {
    gpio_put(MOTOR_DIR_PIN, motor_direction);
    step_state = !step_state;
    gpio_put(MOTOR_STEP_PIN, step_state);

    t->delay_us = -motor_pwm_delay;
  }
  return true;
}

// future core 1 touchscreen function
void core1_entry() {
  while (1) {
    tight_loop_contents();
  }
}

int main() {
  stdio_init_all();
  // give the system and ToF sensor time to stabilize
  sleep_ms(2000);

  i2c_init(I2C_PORT, 400 * 1000); // fast mode 400kHz
  gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);
  gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);
  gpio_pull_up(SDA_PIN);
  gpio_pull_up(SCL_PIN);

  VL53L0X sensor(I2C_PORT, 0x29);
  if (!sensor.init()) {
    printf("failed to detect VL53L0X sensor!\n");
    while (1)
      tight_loop_contents();
  }

  // set timing budget to 20ms for high-speed balancing
  sensor.setMeasurementTimingBudget(20000);
  sensor.startContinuous();

  gpio_init(MOTOR_STEP_PIN);
  gpio_set_dir(MOTOR_STEP_PIN, GPIO_OUT);
  gpio_init(MOTOR_DIR_PIN);
  gpio_set_dir(MOTOR_DIR_PIN, GPIO_OUT);

  float distance = BALL_SETPOINT_CM, set_point = BALL_SETPOINT_CM,
        control_output = 0.0f;
  PID myPID(&distance, &control_output, &set_point, DEFAULT_KP, DEFAULT_KI,
            DEFAULT_KD, DIRECT);

  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(PID_LIMIT_MIN, PID_LIMIT_MAX);
  multicore_launch_core1(core1_entry);

  struct repeating_timer timer;
  add_repeating_timer_us(-1000, motor_step_callback, NULL, &timer);

  while (true) {
    if (multicore_fifo_rvalid()) {
      uint32_t cmd = multicore_fifo_pop_blocking();
      if (cmd == CMD_UPDATE_KP) {
        uint32_t raw_val = multicore_fifo_pop_blocking();
        float new_kp = (float)raw_val / 100.0f;
        myPID.SetTunings(new_kp, myPID.GetKi(), myPID.GetKd());
      }
    }

    uint16_t mm = sensor.readRangeContinuousMillimeters();
    if (!sensor.timeoutOccurred() && mm < 1200) {
      distance = (float)mm / 10.0f; //

      myPID.Compute();

      motor_direction = (control_output > 0) ? CLOCKWISE : COUNTER_CLOCKWISE;

      // Use constant for base delay calculation
      motor_pwm_delay = MOTOR_BASE_DELAY - abs((int)control_output);

      // Use constant for deadzone
      motor_enabled = (abs(control_output) > MOTOR_DEADZONE);

      printf("Dist: %.1f cm | Out: %.1f | Speed: %d\n", distance,
             control_output, motor_pwm_delay);
    } else {
      motor_enabled = false;
    }

    sleep_ms(PID_SAMPLE_MS); // Loop timing from .hpp
  }

  return 0;
}
